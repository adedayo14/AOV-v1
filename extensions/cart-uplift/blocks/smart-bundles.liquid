{% comment %}
  Smart Bundles Block - Displays ML-powered product bundles.
  This block should be placed on product pages where you want bundles to appear.
  The associated 'bundle-renderer.js' asset will handle fetching and rendering.
{% endcomment %}

{% assign cu_version = '4.8' %}
{% if block.settings.enable_smart_bundles %}
<div class="cart-uplift-smart-bundles"
  data-product-id="{{ product.id }}"
  data-bundle-settings='{{ block.settings | json }}'
  data-cu-version="{{ cu_version }}"
  style="margin-top: {{ block.settings.margin_top | default: 20 }}px; margin-bottom: {{ block.settings.margin_bottom | default: 20 }}px;">
  
  {% comment %} Smart Bundles will be dynamically loaded here {% endcomment %}
  <div
    id="smart-bundles-container-{{ product.id }}"
    class="smart-bundles-loading cu-layout-{{ block.settings.bundle_layout }}"
    data-bundle-title="{{ block.settings.bundle_title | escape }}"
    data-layout="{{ block.settings.bundle_layout }}"
  >
    <div class="smart-bundles-placeholder" style="text-align: center; padding: 20px; color: #666;">
    <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite;"></div>
  <p style="margin-top: 10px; font-size: 14px;">Loading smart bundles... v{{ cu_version }}</p>
    </div>
  </div>
</div>

<link rel="stylesheet" href="{{ 'bundles.css' | asset_url }}?v={{ cu_version }}">

<style>
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.cart-uplift-smart-bundles {
  width: 100%;
  max-width: 100%;
}

.smart-bundles-loading {
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.smart-bundles-placeholder {
  opacity: 0.7;
}

/* Hide loading when bundles are loaded */
.smart-bundles-loaded .smart-bundles-placeholder {
  display: none;
}
</style>

<script>
// Initialize Smart Bundles for this product
console.log('[SmartBundles] Script block executing for product {{ product.id | json }} (v{{ cu_version }})');
console.log('[SmartBundles] Available window globals:', {
  BundleRenderer: typeof window.BundleRenderer,
  CartUplift: typeof window.CartUplift,
  CartUpliftSettings: typeof window.CartUpliftSettings
});

// Execute immediately, don't wait for DOM
const productId = {{ product.id | json }};
// Pass store currency and locale into global settings for currency-safe formatting
try {
  window.CartUpliftSettings = Object.assign({}, window.CartUpliftSettings || {}, {
    shopCurrency: {{ shop.currency | json }},
  });
  window.CartUpliftVersion = {{ cu_version | json }};
  // Also set document language if theme hasn't
  if (!document.documentElement.lang) {
    document.documentElement.lang = {{ request.locale | default: shop.locale | json }};
  }
} catch (_) {}
console.log('[SmartBundles] Product ID:', productId);

// Signal globally that a theme Smart Bundles block is present on this page.
// This helps the renderer avoid auto-placement and race conditions.
try {
  window.CartUpliftHasSmartBundleBlock = true;
} catch (_) {}

// Test bundle removed

// Check if container exists immediately
const bundleContainer = document.getElementById('smart-bundles-container-' + productId);
console.log('[SmartBundles] Container element:', bundleContainer);

  if (!bundleContainer) {
  console.error('[SmartBundles] Container not found immediately, will retry on DOM ready');
}

// Ensure renderer won't hide the container if it doesn't find data
try { if (bundleContainer) bundleContainer.dataset.cuFallbackActive = 'true'; } catch(_) {}

function onSmartBundlesDomReady() {
  console.log('[SmartBundles] DOM Content Loaded event fired');
  const bundleContainer = document.getElementById('smart-bundles-container-' + productId);

  console.log('[SmartBundles] DOM loaded, productId:', productId, 'container:', bundleContainer);

  if (!bundleContainer) {
    console.error('[SmartBundles] Bundle container not found!');
    return;
  }

  // Apply theme editor settings (title, layout) after markup is rendered
  function applyThemeEditorSettings() {
    try {
      const titleOverride = bundleContainer.dataset.bundleTitle;
      const titleEl = bundleContainer.querySelector('.cart-uplift-bundle__title');
      if (titleOverride && titleEl && titleEl.textContent !== titleOverride) {
        titleEl.textContent = titleOverride;
      }
      const layout = bundleContainer.dataset.layout || 'horizontal';
      bundleContainer.classList.toggle('cu-layout-horizontal', layout === 'horizontal');
      bundleContainer.classList.toggle('cu-layout-vertical', layout === 'vertical');
    } catch (e) {
      console.warn('[SmartBundles] Failed to apply theme editor settings', e);
    }
  }

  // Mark fallback active so renderer won't hide the container if it finds no data
  try { if (bundleContainer) bundleContainer.dataset.cuFallbackActive = 'true'; } catch(_) {}

  // Consolidated fallback function that tries ML bundles, manual bundles, then Shopify recommendations
  async function tryFallbackBundles(container, source = 'unknown') {
    console.log('[SmartBundles] Starting fallback process from:', source);
    
    try {
      // First: Try to get ML bundles from API
      const response = await fetch('/apps/cart-uplift/api/bundles?product_id=' + productId + '&context=product', {
        headers: { 'Accept': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('[SmartBundles] Fallback API data:', data);
        
        if (data && data.bundles && data.bundles.length > 0) {
          console.log('[SmartBundles] Rendering ML bundles from fallback');
          renderMLBundles(data.bundles, container);
          setTimeout(applyThemeEditorSettings, 50);
          return true;
        }
      }
      
      // Second: Try manual bundles from theme settings
      console.log('[SmartBundles] No ML bundles, checking manual bundles...');
      const manualBundles = getManualBundlesFromSettings();
      if (manualBundles && manualBundles.length > 0) {
        console.log('[SmartBundles] Rendering manual bundles from fallback');
        renderManualBundles(manualBundles, container);
        setTimeout(applyThemeEditorSettings, 50);
        return true;
      }
      
      // Third: Try Shopify product recommendations
      console.log('[SmartBundles] No manual bundles, trying Shopify recommendations...');
      const products = await loadAnyFallbackProducts(productId, 4);
      if (Array.isArray(products) && products.length > 0) {
        console.log('[SmartBundles] Rendering Shopify recommendations from fallback');
        renderShopifyRecommendationsInContainer(products, container);
        setTimeout(applyThemeEditorSettings, 50);
        return true;
      }
      
      // Last resort: Show empty state
      console.log('[SmartBundles] No fallback products available; showing empty state');
      container.classList.add('smart-bundles-loaded');
      container.innerHTML = '<div class="smart-bundles-placeholder" style="text-align:center;padding:16px;color:#777;">No recommendations right now</div>';
      return false;
      
    } catch (error) {
      console.error('[SmartBundles] Fallback failed:', error);
      container.classList.add('smart-bundles-loaded');
      container.innerHTML = '<div class="smart-bundles-placeholder" style="text-align:center;padding:16px;color:#777;">No recommendations right now</div>';
      return false;
    }
  }

  const tryInit = (attempt = 1) => {
    if (!bundleContainer) {
      console.error('[SmartBundles] Bundle container not found');
      return;
    }

    console.log('[SmartBundles] Attempt', attempt, 'to initialize bundles for product:', productId);

    // Preferred path via CartUplift facade
    if (typeof window.CartUplift !== 'undefined' && window.CartUplift.initSmartBundles) {
      console.log('[SmartBundles] Using CartUplift facade');
      window.CartUplift.initSmartBundles(productId, bundleContainer);
      setTimeout(applyThemeEditorSettings, 100);
      return;
    }

    // Direct path if renderer is already present
    if (window.BundleRenderer) {
      console.log('[SmartBundles] BundleRenderer class found, initializing...');
      if (!window.cartUpliftBundleRenderer) {
        try {
          const settings = window.CartUpliftSettings || window.cartUpliftSettings || {};
          console.log('[SmartBundles] Creating BundleRenderer with settings:', settings);
          window.cartUpliftBundleRenderer = new window.BundleRenderer(settings);
          console.log('[SmartBundles] BundleRenderer instance created successfully');
        } catch (e) {
          console.error('[SmartBundles] Error creating BundleRenderer:', e);
          return;
        }
      }
      if (window.cartUpliftBundleRenderer && typeof window.cartUpliftBundleRenderer.initProductPage === 'function') {
        console.log('[SmartBundles] Calling initProductPage for product:', productId);
        try {
          window.cartUpliftBundleRenderer.initProductPage(productId, bundleContainer);
          setTimeout(applyThemeEditorSettings, 100);
          console.log('[SmartBundles] initProductPage call completed');
          return;
        } catch (e) {
          console.error('[SmartBundles] Error calling initProductPage:', e);
        }
      } else {
        console.warn('[SmartBundles] BundleRenderer missing initProductPage method');
      }
    } else {
      console.log('[SmartBundles] BundleRenderer class not found, waiting... (attempt ' + attempt + ')');
      console.log('[SmartBundles] Available globals:', {
        CartUplift: typeof window.CartUplift,
        CartUpliftAssets: window.CartUpliftAssets,
        CartUpliftSettings: typeof window.CartUpliftSettings,
        BundleRenderer: typeof window.BundleRenderer
      });
      
      // Try to load the script if we have the asset URL but no script tag
      if (window.CartUpliftAssets && window.CartUpliftAssets.bundleRenderer && attempt === 1) {
        console.log('[SmartBundles] Loading bundle renderer from app-embed asset URL...');
        const existing = document.querySelector('script[data-cartuplift="bundle-renderer"]');
        if (!existing) {
          const script = document.createElement('script');
          script.src = window.CartUpliftAssets.bundleRenderer;
          script.defer = true;
          script.setAttribute('data-cartuplift', 'bundle-renderer');
          script.onload = () => console.log('[SmartBundles] Bundle renderer script loaded successfully');
          script.onerror = () => console.error('[SmartBundles] Failed to load bundle renderer script');
          document.head.appendChild(script);
          console.log('[SmartBundles] Bundle renderer script added to DOM');
        } else {
          console.log('[SmartBundles] Bundle renderer script already exists in DOM');
        }
      }
    }

    if (attempt <= 6) {
      setTimeout(() => tryInit(attempt + 1), 500);
    } else {
  } else {
      console.log('[SmartBundles] All attempts failed, trying consolidated fallback...');
      tryFallbackBundles(bundleContainer, 'tryInit');
    }

  // Render ML bundles from API response
  function renderMLBundles(bundles, container) {
    if (!Array.isArray(bundles) || bundles.length === 0) return;
    
    container.classList.add('smart-bundles-loaded', 'cu-manual-rendered');
    container.innerHTML = '';

    const bundle = bundles[0]; // Use first/best bundle
    const docLang = (document.documentElement && document.documentElement.lang) || 'en';
    const shopCurrency = (window.CartUpliftSettings && window.CartUpliftSettings.shopCurrency) || (window.cartUpliftSettings && window.cartUpliftSettings.shopCurrency) || {{ shop.currency | json }};
    const fmt = (v) => new Intl.NumberFormat(docLang, { style: 'currency', currency: shopCurrency }).format(v);

    // Normalize bundle products
    const bundleProducts = (bundle.products || []).map(function(p, idx) {
      const price = typeof p.price === 'number' ? p.price : 0;
      const image = p.image || generatePlaceholderSvg(p.title || 'Product', idx);
      return { ...p, price, image };
    });

    const itemsHtml = bundleProducts.map(function(product, idx) {
      return (
        '<div class="cu-item">' +
        '<div class="cu-item__image-wrap"><img class="cu-item__image" src="' + product.image + '" alt="' + (product.title || '') + '"></div>' +
        '<div class="cu-item__title">' + (product.title || '') + '</div>' +
        '<div class="cu-item__price">' + fmt(product.price) + '</div>' +
        '</div>'
      );
    }).join('');

    const bundlePrice = typeof bundle.bundle_price === 'number' ? bundle.bundle_price : 0;
    const regularPrice = typeof bundle.regular_total === 'number' ? bundle.regular_total : bundlePrice;
    const discountPercent = typeof bundle.discount_percent === 'number' ? bundle.discount_percent : 0;

    const wrapper = document.createElement('div');
    wrapper.className = 'cart-uplift-bundle';
    wrapper.innerHTML = (
      '<div class="cart-uplift-bundle__content">'
      + '<div class="cart-uplift-bundle__header">'
      + '<h3 class="cart-uplift-bundle__title">' + (bundle.name || bundle.title || 'Perfect Match Bundle') + '</h3>'
      + '</div>'
      + '<div class="cu-grid">' + itemsHtml + '</div>'
      + '<div class="cu-total">'
      +   '<div class="cu-total__label">Bundle price</div>'
      +   '<div class="cu-total__values">'
      +     '<span class="cu-total__price">' + fmt(bundlePrice) + '</span>'
      +     (regularPrice > bundlePrice ? '<span class="cu-total__regular">' + fmt(regularPrice) + '</span>' : '')
      +     (discountPercent > 0 ? '<span class="cu-total__save">Save ' + discountPercent + '%</span>' : '')
      +   '</div>'
      + '</div>'
      + '<div class="cart-uplift-bundle__actions">'
      +   '<button class="cart-uplift-bundle__cta" data-cu-ml-bundle="' + (bundle.id || '') + '">Add bundle to cart</button>'
      + '</div>'
      + '</div>'
    );
    container.appendChild(wrapper);

    const cta = wrapper.querySelector('[data-cu-ml-bundle]');
    if (cta) {
      cta.addEventListener('click', async function() {
        try {
          cta.disabled = true;
          const bundleId = cta.getAttribute('data-cu-ml-bundle');
          
          // Try to add bundle via specific API first
          let success = false;
          try {
            const resp = await fetch('/apps/cart-uplift/api/bundles/add', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ bundle_id: bundleId })
            });
            if (resp.ok) {
              success = true;
              alert('Bundle added to cart!');
              // Optionally redirect to cart
              if (confirm('View cart now?')) window.location.href = '/cart';
            }
          } catch (e) {
            console.warn('[SmartBundles] Bundle API add failed, trying individual products:', e);
          }
          
          // Fallback: add individual products
          if (!success) {
            const items = bundleProducts.map(function(p) {
              const variantId = p.variant_id || p.id;
              return { id: parseInt(variantId, 10), quantity: 1 };
            }).filter(function(item) { return !isNaN(item.id); });
            
            if (items.length > 0) {
              const resp = await fetch('/cart/add.js', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ items: items })
              });
              if (resp.ok) {
                alert('Bundle products added to cart!');
              } else {
                throw new Error('Failed to add bundle products');
              }
            } else {
              throw new Error('No valid products in bundle');
            }
          }
        } catch (e) {
          console.warn('[SmartBundles] Failed to add ML bundle to cart:', e);
          alert('Failed to add bundle to cart');
        } finally {
          cta.disabled = false;
        }
      });
    }
  }

  // Get manual bundles from theme settings
  function getManualBundlesFromSettings() {
    try {
      const bundleSettings = bundleContainer.dataset.bundleSettings;
      if (bundleSettings) {
        const settings = JSON.parse(bundleSettings);
        // The new setting is `manual_bundle_products` which is an array of product objects
        if (settings.manual_bundle_products && Array.isArray(settings.manual_bundle_products) && settings.manual_bundle_products.length > 0) {
          
          // We need to format this into a bundle structure that renderManualBundles expects.
          // Let's create one bundle object containing these products.
          const products = settings.manual_bundle_products.map(p => {
            // The product object from product_list is a bit different. We need to adapt it.
            // The price from the product_list setting is already in cents (integer).
            return {
              id: p.id,
              variant_id: p.variants[0].id, // Use first variant
              title: p.title,
              price: p.price, // price is in cents
              image: p.featured_image,
              quantity: 1
            };
          });

          const regularTotal = products.reduce((sum, p) => sum + (p.price || 0), 0);

          const manualBundle = {
            id: 'manual-bundle-1',
            name: 'Our Handpicked Bundle',
            products: products,
            bundle_price: regularTotal, // By default, no discount for manual bundle
            regular_total: regularTotal,
            discount_percent: 0
          };

          // renderManualBundles expects an array of bundles
          return [manualBundle];
        }
      }
    } catch (e) {
      console.warn('[SmartBundles] Failed to parse or process manual bundle settings:', e);
    }
    return null;
  }

  // Render manual bundles from settings
  function renderManualBundles(manualBundles, container) {
    if (!Array.isArray(manualBundles) || manualBundles.length === 0) return;
    
    container.classList.add('smart-bundles-loaded', 'cu-manual-rendered');
    container.innerHTML = '';

    const bundle = manualBundles[0]; // Use first manual bundle
    const docLang = (document.documentElement && document.documentElement.lang) || 'en';
    const shopCurrency = (window.CartUpliftSettings && window.CartUpliftSettings.shopCurrency) || (window.cartUpliftSettings && window.cartUpliftSettings.shopCurrency) || {{ shop.currency | json }};
    // Manual bundles come with prices in cents, so we need to divide by 100 before formatting
    const fmt = (v) => new Intl.NumberFormat(docLang, { style: 'currency', currency: shopCurrency }).format(v / 100);

    // Manual bundles might have different data structure
    const bundleProducts = (bundle.products || []).map(function(p, idx) {
      const price = typeof p.price === 'number' ? p.price : 0; // price is in cents from theme editor
      const image = p.image || generatePlaceholderSvg(p.title || 'Product', idx);
      return { ...p, price, image };
    });

    const itemsHtml = bundleProducts.map(function(product, idx) {
      return (
        '<div class="cu-item">' +
        '<div class="cu-item__image-wrap"><img class="cu-item__image" src="' + product.image + '" alt="' + (product.title || '') + '"></div>' +
        '<div class="cu-item__title">' + (product.title || '') + '</div>' +
        '<div class="cu-item__price">' + fmt(product.price) + '</div>' +
        '</div>'
      );
    }).join('');

    const bundlePrice = typeof bundle.bundle_price === 'number' ? bundle.bundle_price : bundleProducts.reduce(function(sum, p) { return sum + p.price; }, 0);
    const regularPrice = typeof bundle.regular_total === 'number' ? bundle.regular_total : bundlePrice;

    const wrapper = document.createElement('div');
    wrapper.className = 'cart-uplift-bundle cart-uplift-manual-bundle';
    wrapper.innerHTML = (
      '<div class="cart-uplift-bundle__content">'
      + '<div class="cart-uplift-bundle__header">'
      + '<h3 class="cart-uplift-bundle__title">' + (bundle.name || bundle.title || 'Curated Bundle') + '</h3>'
      + '</div>'
      + '<div class="cu-grid">' + itemsHtml + '</div>'
      + '<div class="cu-total">'
      +   '<div class="cu-total__label">Bundle price</div>'
      +   '<div class="cu-total__values">'
      +     '<span class="cu-total__price">' + fmt(bundlePrice) + '</span>'
      +     (regularPrice > bundlePrice ? '<span class="cu-total__regular">' + fmt(regularPrice) + '</span>' : '')
      +   '</div>'
      + '</div>'
      + '<div class="cart-uplift-bundle__actions">'
      +   '<button class="cart-uplift-bundle__cta" data-cu-manual-bundle="true">Add bundle to cart</button>'
      + '</div>'
      + '</div>'
    );
    container.appendChild(wrapper);

    const cta = wrapper.querySelector('[data-cu-manual-bundle]');
    if (cta) {
      cta.addEventListener('click', async function() {
        try {
          cta.disabled = true;
          const items = bundleProducts.map(function(p) {
            const variantId = p.variant_id || p.id;
            return { id: parseInt(variantId, 10), quantity: 1 };
          }).filter(function(item) { return !isNaN(item.id); });
          
          if (items.length > 0) {
            const resp = await fetch('/cart/add.js', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ items: items })
            });
            if (resp.ok) {
              alert('Manual bundle added to cart!');
            } else {
              throw new Error('Failed to add manual bundle');
            }
          } else {
            throw new Error('No valid products in manual bundle');
          }
        } catch (e) {
          console.warn('[SmartBundles] Failed to add manual bundle to cart:', e);
          alert('Failed to add bundle to cart');
        } finally {
          cta.disabled = false;
        }
      });
    }
  }

  // Generate placeholder SVG for products without images
  function generatePlaceholderSvg(title, idx) {
    const colors = ['#007c89','#d73027','#28a745','#6f42c1'];
    const color = colors[idx % colors.length];
    const shortTitle = (title || '').slice(0, 10);
    return 'data:image/svg+xml,' + encodeURIComponent(
      "<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120'>"
      + "<rect width='100%' height='100%' fill='" + color + "'/>"
      + "<text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='white' font-family='Arial' font-size='12'>" + shortTitle + "</text>"
      + "</svg>"
    );
  }

  // Fetch Shopify native product recommendations
  function fetchShopifyRecommendations(productId, limit) {
    const url = '/recommendations/products.json?product_id=' + encodeURIComponent(productId) + '&limit=' + encodeURIComponent(limit || 4);
    return fetch(url, { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' })
      .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
      .then(data => Array.isArray(data) ? data : (Array.isArray(data && data.products) ? data.products : []));
  }

  // Storewide fallback: grab a few products if recs are empty
  function fetchStorewideProducts(limit) {
    const url = '/products.json?limit=' + encodeURIComponent(limit || 4);
    return fetch(url, { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' })
      .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
      .then(j => Array.isArray(j && j.products) ? j.products : [])
      .then(products => products.map(function(p){
        return {
          id: p && p.id,
          handle: p && p.handle,
          title: p && p.title,
          price: (function(){ try { var v=p && p.variants && p.variants[0]; return v && v.price ? Math.round(parseFloat(v.price)*100) : null; } catch(_) { return null; } })(),
          featured_image: (p && p.image && (p.image.src || p.image)) || (p && p.images && p.images[0] && (p.images[0].src || p.images[0])) || null,
          images: (p && Array.isArray(p.images)) ? p.images.map(function(i){ return i && (i.src || i); }) : [],
          variants: Array.isArray(p && p.variants) ? p.variants.map(function(v){ return { id: v && v.id, available: v ? (v.available !== false) : false }; }) : []
        };
      }));
  }

  // Unified loader: try recs then storewide products
  function loadAnyFallbackProducts(productId, limit) {
    return fetchShopifyRecommendations(productId, limit).then(function(recs){
      if (Array.isArray(recs) && recs.length > 0) return recs;
      return fetchStorewideProducts(limit).then(function(list){ return list; }).catch(function(){ return []; });
    }).catch(function(){
      return fetchStorewideProducts(limit).catch(function(){ return []; });
    });
  }

  // Render Shopify native recommendations into the same container (3 items + total + Add all CTA)
  function renderShopifyRecommendationsInContainer(products, container) {
    if (!Array.isArray(products) || products.length === 0) return;
    // Mark as manually rendered so the JS renderer won't override later
    container.classList.add('smart-bundles-loaded', 'cu-manual-rendered');
    container.innerHTML = '';

    const docLang = (document.documentElement && document.documentElement.lang) || 'en';
    const shopCurrency = (window.CartUpliftSettings && window.CartUpliftSettings.shopCurrency) || (window.cartUpliftSettings && window.cartUpliftSettings.shopCurrency) || {{ shop.currency | json }};
    const fmt = (v) => new Intl.NumberFormat(docLang, { style: 'currency', currency: shopCurrency }).format(v);

    const norm = function(p) {
      const id = p && (p.id || p.product_id || p.gid) || null;
      const handle = (p && p.handle) || '';
      const title = (p && p.title) || '';
      const priceCents = (p && typeof p.price === 'number') ? p.price : ((p && typeof p.price_min === 'number') ? p.price_min : null);
      const price = priceCents != null ? priceCents / 100 : null;
      const image = (p && (p.featured_image && (p.featured_image.url || p.featured_image)) ) || (p && p.images && p.images[0]) || (p && p.image) || null;
      const url = handle ? ('/products/' + handle) : (p && p.url) || '#';
      const variants = Array.isArray(p && p.variants) ? p.variants : null;
      return { id, handle, title, price, image, url, variants };
    };

    const recs = (products || []).slice(0, 3).map(function(p, idx){ return { pr: norm(p), idx: idx, raw: p }; });
    const itemsHtml = recs.map(function(item){
      const pr = item.pr; const idx = item.idx;
      const svgPh = encodeURIComponent(
        "<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120'>"
        + "<rect width='100%' height='100%' fill='" + ['#007c89','#d73027','#28a745','#6f42c1'][idx%4] + "'/>"
        + "<text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='white' font-family='Arial' font-size='12'>" + (pr.title||'').slice(0,10) + "</text>"
        + "</svg>"
      );
      const imgUrl = (pr.image && typeof pr.image === 'string') ? pr.image : ('data:image/svg+xml,' + svgPh);
      const priceHtml = (typeof pr.price === 'number') ? ('<div class="cu-item__price">' + fmt(pr.price) + '</div>') : '';
      return (
        '<a class="cu-item" href="' + pr.url + '" aria-label="' + pr.title + '">' +
        '<div class="cu-item__image-wrap"><img class="cu-item__image" src="' + imgUrl + '" alt="' + pr.title + '"></div>' +
        '<div class="cu-item__title">' + pr.title + '</div>' +
        priceHtml +
        '</a>'
      );
    }).join('');

    var total = recs.reduce(function(s, it){ return s + (typeof it.pr.price === 'number' ? it.pr.price : 0); }, 0);

    const wrapper = document.createElement('div');
    wrapper.className = 'cart-uplift-recs';
    wrapper.innerHTML = (
      '<div class="cart-uplift-bundle">'
      + '<div class="cart-uplift-bundle__content">'
      + '<div class="cart-uplift-bundle__header">'
      + '<h3 class="cart-uplift-bundle__title">You may also like</h3>'
      + '</div>'
      + '<div class="cu-grid">' + itemsHtml + '</div>'
      + '<div class="cu-total">'
      +   '<div class="cu-total__label">Total price</div>'
      +   '<div class="cu-total__values"><span class="cu-total__price">' + fmt(total) + '</span></div>'
      + '</div>'
      + '<div class="cart-uplift-bundle__actions">'
      +   '<button class="cart-uplift-bundle__cta" data-cu-recs-cta="true">Add all to cart</button>'
      + '</div>'
      + '</div>'
      + '</div>'
    );
    container.appendChild(wrapper);

    async function resolveVariantId(item){
      // Prefer first available from provided variants
      const vlist = Array.isArray(item && item.raw && item.raw.variants) ? item.raw.variants : (Array.isArray(item && item.pr && item.pr.variants) ? item.pr.variants : null);
      if (vlist && vlist.length > 0) {
        const avail = vlist.find(function(v){ return v && v.available; }) || vlist[0];
        if (avail && avail.id) return avail.id;
      }
      // Fallback: fetch product JSON by handle to get variants
      try {
        if (item && item.pr && item.pr.handle) {
          const r = await fetch('/products/' + item.pr.handle + '.js', { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' });
          if (r.ok) {
            const j = await r.json();
            const v = Array.isArray(j && j.variants) ? (j.variants.find(function(v){ return v && v.available; }) || j.variants[0]) : null;
            if (v && v.id) return v.id;
          }
        }
      } catch(_){ }
      return null;
    }

    const cta = wrapper.querySelector('[data-cu-recs-cta="true"]');
    if (cta) {
      cta.addEventListener('click', async function(){
        try {
          cta.disabled = true;
          const vids = (await Promise.all(recs.map(resolveVariantId))).filter(Boolean);
          if (vids.length === 0) throw new Error('No variants');
          const items = vids.map(function(id){ return { id: id, quantity: 1 }; });
          const resp = await fetch('/cart/add.js', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, credentials: 'same-origin', body: JSON.stringify({ items: items }) });
          if (!resp.ok) throw new Error('batch failed');
          alert('Products added to cart');
        } catch (e) {
          console.warn('[SmartBundles] Failed to add recommendations to cart:', e);
          alert('Failed to add products to cart');
        } finally {
          cta.disabled = false;
        }
      });
    }
  }

  // Smart fallback system with progressive checks
  let fallbackAttempts = 0;
  const maxFallbackAttempts = 3;
  
  function smartFallbackCheck() {
    try {
      const container = document.getElementById('smart-bundles-container-' + productId);
      if (!container) return;
      
      const hasRealContent = !!(container && (container.querySelector('.cart-uplift-recs') || container.querySelector('.cart-uplift-bundle')));
      
      if (!hasRealContent && fallbackAttempts < maxFallbackAttempts) {
        fallbackAttempts++;
        console.log('[SmartBundles] Smart fallback check attempt', fallbackAttempts);
        
        // Use the consolidated fallback function
        tryFallbackBundles(container, 'smartFallbackCheck');
      }
    } catch (e) {
      console.warn('[SmartBundles] Smart fallback check failed:', e);
    }
  }

  // If the renderer doesn't populate within progressive timing, use smart fallback
  function ensureRecommendationsFallbackSoon() {
    smartFallbackCheck();
  }

  // Watchdog: try a second time in case something cleared the container later
  function ensureRecommendationsFallbackWatchdog() {
    smartFallbackCheck();
  }

  // Debug helper to check ML bundle status
  window.debugCartUpliftBundles = async function() {
    const currentProductId = productId;
    
    console.group('Cart Uplift Bundle Debug (v{{ cu_version }})');
    
    // Check if bundle renderer is loaded
    console.log('BundleRenderer loaded:', typeof window.BundleRenderer !== 'undefined');
    console.log('CartUplift facade loaded:', typeof window.CartUplift !== 'undefined');
    console.log('Product ID:', currentProductId);
    
    // Check container state
    const container = document.getElementById('smart-bundles-container-' + currentProductId);
    console.log('Container found:', !!container);
    if (container) {
      console.log('Container classes:', container.className);
      console.log('Container innerHTML length:', container.innerHTML.length);
      console.log('Has real content:', !!(container.querySelector('.cart-uplift-recs') || container.querySelector('.cart-uplift-bundle')));
    }
    
    // Check API response
    try {
      const response = await fetch('/apps/cart-uplift/api/bundles?product_id=' + currentProductId + '&context=product');
      const data = await response.json();
      
      console.log('API Response Status:', response.status);
      console.log('API Response Headers:', Object.fromEntries(response.headers.entries()));
      console.log('API Response Data:', data);
      
      if (data.bundles && data.bundles.length > 0) {
        console.log('✅ ML Bundles Available:', data.bundles.length);
        data.bundles.forEach((b, i) => {
          console.log(`Bundle ${i + 1}:`, {
            id: b.id,
            name: b.name || b.title,
            products: b.products?.length || 0,
            bundle_price: b.bundle_price,
            regular_total: b.regular_total,
            discount_percent: b.discount_percent
          });
        });
      } else {
        console.log('❌ No ML Bundles Available');
        console.log('Reason:', data.reason || 'Unknown');
        console.log('Possible reasons:');
        console.log('- Insufficient order history with this product');
        console.log('- Product not frequently bought with others');
        console.log('- ML model still training');
        console.log('- Bundle feature not enabled in Cart Uplift app');
      }
    } catch (error) {
      console.error('API Error:', error);
    }
    
    // Check manual bundles
    const manualBundles = getManualBundlesFromSettings();
    console.log('Manual bundles from settings:', manualBundles);
    
    console.groupEnd();
  };

  // Auto-run debug in development or with debug flag
  if (window.location.hostname.includes('localhost') || window.location.search.includes('debug=true') || window.location.search.includes('cu_debug=1')) {
    setTimeout(() => window.debugCartUpliftBundles(), 2000);
  }

  // Legacy no-op kept for backward compatibility
  window.addBundleToCart = function(bundleId) {
    console.log('[SmartBundles] Deprecated addBundleToCart called for', bundleId);
  };

  tryInit();
  setTimeout(ensureRecommendationsFallbackSoon, 2000);
  setTimeout(ensureRecommendationsFallbackWatchdog, 4500);
}

// Run immediately if DOMContentLoaded already fired (e.g., block injected dynamically),
// otherwise wait for DOMContentLoaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', onSmartBundlesDomReady);
} else {
  try { onSmartBundlesDomReady(); } catch (e) { console.warn('[SmartBundles] Init failed:', e); }
}
</script>

{%- comment -%}
  Ensure the bundle renderer script is available on product pages using this block.
  This is a safe fallback in case the app-embed delayed loader hasn’t run yet.
{%- endcomment -%}
<script src="{{ 'bundle-renderer.js' | asset_url }}?v={{ cu_version }}" defer></script>
{% endif %}

{% schema %}
{
  "name": "Smart Bundles",
  "target": "section",
  "settings": [
    {
      "type": "checkbox",
      "id": "enable_smart_bundles",
      "label": "Enable Smart Bundles",
      "default": true,
      "info": "Show AI-powered product bundles on this product page"
    },
    {
      "type": "text",
      "id": "bundle_title",
      "label": "Bundle Title",
      "default": "Complete your setup",
      "info": "Title shown above the bundle recommendations"
    },
    {
      "type": "select",
      "id": "bundle_layout",
      "label": "Bundle Layout",
      "options": [
        {
          "value": "horizontal",
          "label": "Horizontal (side by side)"
        },
        {
          "value": "vertical",
          "label": "Vertical (stacked)"
        }
      ],
      "default": "horizontal"
    },
    {
      "type": "product_list",
      "id": "manual_bundle_products",
      "label": "Manual Fallback Bundle",
      "limit": 4,
      "info": "Select products for a manual bundle if no ML recommendations are found. The first product is the main product."
    },
    {
      "type": "range",
      "id": "margin_top",
      "min": 0,
      "max": 50,
      "step": 5,
      "unit": "px",
      "label": "Top margin",
      "default": 20
    },
    {
      "type": "range",
      "id": "margin_bottom", 
      "min": 0,
      "max": 50,
      "step": 5,
      "unit": "px",
      "label": "Bottom margin",
      "default": 20
    }
  ]
}
{% endschema %}
